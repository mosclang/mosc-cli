// Generated automatically from src/cli/*.msc. Do not edit.
static const char* cliModuleSource =
"##package=resolver,cli\n"
"\n"
"kulu SiraSukuya {\n"
"  dialen SIMPLE { 1 }\n"
"  dialen ABSOLUTE { 2 }\n"
"  dialen RELATIVE { 3 }\n"
"\n"
"  dialen unixAbsolute(path) { path.beDamineNiin(\"/\") }\n"
"  dialen windowsAbsolute(path) {\n"
"    # TODO: is this not escaped properly by the stock Python code generator\n"
"    segin niin path.hakan >= 3 && path[1..2] == \":\\\\\"\n"
"  }\n"
"  dialen resolve(path) {\n"
"    nii (path.beDamineNiin(\".\")) segin niin SiraSukuya.RELATIVE\n"
"    nii (SiraSukuya.unixAbsolute(path)) segin niin SiraSukuya.ABSOLUTE\n"
"    nii (SiraSukuya.windowsAbsolute(path)) segin niin SiraSukuya.ABSOLUTE\n"
"\n"
"    segin niin SiraSukuya.SIMPLE\n"
"  }\n"
"}\n"
"\n"
"\n\n"
"##package=resolver,cli\n"
"kulu Sira {\n"
"  nin _path\n"
"  nin _sep\n"
"  dilan kura(path) {\n"
"    ale._path = path\n"
"    ale._sep = nii ale.appearsWindows()  \"\\\\\" note \"/\"\n"
"  }\n"
"  appearsWindows() {\n"
"    nii (ale._path.bAkono(\"\\\\\")) segin niin tien\n"
"    nii (ale._path.hakan>=2 && ale._path[1] == \":\") segin niin tien\n"
"  }\n"
"  sep { ale._sep || \"/\" }\n"
"  sebenma { ale._path }\n"
"  sanFe() { ale.kunBen(\"..\") } #up\n"
"  kunBen(path) { Sira.kura(ale._path + ale.sep + path).normalize }\n"
"  damineDo { #isRoot\n"
"    segin niin ale._path == \"/\"  ||\n"
"      ## C:\n"
"      (ale._path.hakan == 2 && ale._path[1] == \":\") ||\n"
"      ## F:\\\n"
"      (ale._path.hakan == 3 && ale._path[1..2] == \":\\\\\")\n"
"  }\n"
"  dirname {\n"
"    nii (ale._path==\"/\") segin niin ale\n"
"    nii (ale._path.beBanNiinAye(ale.sep)) segin niin Sira.kura(ale._path[0..-2])\n"
"    segin niin ale.sanFe()\n"
"  }\n"
"  dialen faraFara(path) {\n"
"    nin segments = []\n"
"    nin last = 0\n"
"    nin i = 0\n"
"    foo (i < path.hakan) {\n"
"      nin char = path[i]\n"
"      nii (char == \"/\" || char == \"\\\\\") {\n"
"        nii (last==i) {\n"
"          segments.aFaraAkan(\"\")\n"
"        } note {\n"
"          segments.aFaraAkan(path[last...i])\n"
"        }\n"
"        last = i + 1\n"
"      }\n"
"      i = i + 1\n"
"    }\n"
"    nii (last<path.hakan) {\n"
"      segments.aFaraAkan(path[last..-1])\n"
"    } note nii (last==i) {\n"
"      segments.aFaraAkan(\"\")\n"
"    }\n"
"    segin niin segments\n"
"  }\n"
"  normalize {\n"
"    ## nin paths = ale._path.split(ale.sep)\n"
"    nin paths = Sira.faraFara(ale._path)\n"
"    nin finalPaths = []\n"
"    nii (ale._path.beDamineNiin(\"/\")) finalPaths.aFaraAkan(\"/\")\n"
"    nii (paths[0]==\".\") finalPaths.aFaraAkan(\".\")\n"
"    seginka (paths kono path) {\n"
"      nin last = nii finalPaths.hakan > 0  finalPaths[-1] note gansan\n"
"      nii (path == \"..\") {\n"
"        nii (last == \"/\") ipan\n"
"\n"
"        nii (last == \".\")  {\n"
"          finalPaths[-1] = \"..\"\n"
"        } note nii (last == \"..\" || last == gansan) {\n"
"          finalPaths.aFaraAkan(\"$path\")\n"
"        } note {\n"
"          nii (finalPaths.hakan > 0) finalPaths.aBoOyorola(finalPaths.hakan - 1)\n"
"        }\n"
"      } note nii (path == \"\" || path == \".\") {\n"
"        ipan\n"
"      } note {\n"
"        finalPaths.aFaraAkan(path)\n"
"      }\n"
"    }\n"
"    nii (finalPaths.hakan>1 && finalPaths[0] == \"/\") finalPaths[0] = \"\"\n"
"    nin path = finalPaths.kunBen(ale.sep)\n"
"    nii (path == \"\") path = \".\"\n"
"    segin niin Sira.kura(path)\n"
"  }\n"
"}\n"
"\n\n"
"kabo \"repl\" nani Repl, AnsiRepl, SimpleRepl\n"
"kabo \"os\" nani Platform, Process\n"
"kabo \"io\" nani Stdin, Stderr, Gafe, Stdout, Stat\n"
"kabo \"dumare\" nani Dumare\n"
"kabo \"fan\" nani Fan\n"
"kabo \"runtime\" nani Runtime\n"
"\n"
"kulu StackTrace {\n"
"  nin _fiber\n"
"  nin _trace\n"
"  dilan kura(fiber) {\n"
"    ale._fiber = fiber\n"
"    ale._trace = Dumare.diaaBo(fiber).stackTrace\n"
"  }\n"
"  print() {\n"
"    Stderr.print(ale._fiber.fili)\n"
"    nin out = ale._trace.frames.yelema { (f) =>\n"
"        segin niin \"at ${ f.methodMirror.signature } (${ f.methodMirror.moduleMirror } line ${ f.line })\"\n"
"    }.kunBen(\"\\n\")\n"
"    Stderr.print(out)\n"
"  }\n"
"}\n"
"\n"
"kulu CLI {\n"
"  dialen start() {\n"
"    # TODO: pull out argument processing into it's own class\n"
"    nii (Process.allArguments.hakan >=2) {\n"
"      nin flag = Process.allArguments[1]\n"
"      nii (flag == \"--version\" || flag == \"-v\") {\n"
"        CLI.showVersion()\n"
"        segin\n"
"      }\n"
"      nii (flag == \"--help\" || flag == \"-h\") {\n"
"        CLI.showHelp()\n"
"        segin\n"
"      }\n"
"      nii (flag == \"-e\" && Process.allArguments.hakan >= 3) {\n"
"        nin code = Process.allArguments[2]\n"
"        CLI.runCode(code,\"<eval>\")\n"
"        segin\n"
"      }\n"
"    }\n"
"\n"
"    nii (Process.allArguments.hakan == 1) {\n"
"      CLI.repl()\n"
"    } note {\n"
"      CLI.runFile(Process.allArguments[1])\n"
"    }\n"
"    Stdout.flush()\n"
"  }\n"
"  dialen versionInfo {\n"
"    segin niin \"moscc v${Runtime.VERSION.labanSanuya(\".0\")} \" +\n"
"    \"(with mosc v${Runtime.MOSC_VERSION.labanSanuya(\".0\")})\"\n"
"  }\n"
"  dialen showVersion() {\n"
"   A.yira(CLI.versionInfo)\n"
"  }\n"
"  dialen showHelp() {\n"
"   A.yira(\"Usage: moscc [file] [arguments...]\")\n"
"   A.yira(\"\")\n"
"   A.yira(\"Optional arguments:\")\n"
"   A.yira(\"  -                read script from stdin\")\n"
"   A.yira(\"  -h, --help       print mosc command line options\")\n"
"   A.yira(\"  -v, --version    print moscc and Mosc version\")\n"
"   A.yira(\"  -e '[code]'      evaluate code\")\n"
"   A.yira()\n"
"   A.yira(\"Documentation can be found at https://github.com/molobala/moscc\")\n"
"\n"
"  }\n"
"  dialen dirForModule(file) {\n"
"    segin niin Sira.kura(file).dirname.sebenma\n"
"  }\n"
"  dialen missingScript(file) {\n"
"    Stderr.print(\"moscc: No such file -- $file\")\n"
"  }\n"
"  dialen runCode(code,moduleName) {\n"
"    nin fn = Fan.compile(code, moduleName)\n"
"    nii (fn != gansan) {\n"
"      nin fb = Djuru.kura (fn)\n"
"      fb.aladie()\n"
"      nii (fb.fili) {\n"
"        StackTrace.kura(fb).print()\n"
"        Process.exit(70)\n"
"      }\n"
"    } note {\n"
"      Process.exit(65)\n"
"    }\n"
"  }\n"
"  dialen runInput() {\n"
"    nin code = \"\"\n"
"    foo(!Stdin.isClosed) code = code + Stdin.read()\n"
"    CLI.runCode(code,\"(script)\")\n"
"    segin\n"
"  }\n"
"  dialen runFile(file) {\n"
"    nin moduleName\n"
"\n"
"    nii (file == \"-\") segin niin CLI.runInput()\n"
"    nii (!Gafe.exists(file)) segin niin CLI.missingScript(file)\n"
"\n"
"    nii (SiraSukuya.resolve(file) == SiraSukuya.ABSOLUTE) {\n"
"      moduleName = file\n"
"    } note {\n"
"      moduleName = \"./\" + file\n"
"    }\n"
"\n"
"    nin code = Gafe.read(file)\n"
"    CLI.setRootDirectory_(CLI.dirForModule(moduleName))\n"
"    CLI.runCode(code,moduleName)\n"
"  }\n"
"  dialen repl() {\n"
"   #A.yira(\"\"\" -\"\\//\"\"\")\n"
"   #A.yira(\"  \\\\_/    \\n${CLI.versionInfo}\")\n"
"\n"
"   A.seben(\"___    ___\\n\");\n"
"   A.seben(\"||\\\\\\\\__//||\\n\");\n"
"   A.seben(\"|| \\\\\\\\// ||\\n\");\n"
"   A.seben(\"||      ||\\n\");\n"
"   A.seben(\"{{      }} osc cli \\n${CLI.versionInfo}\\n\\n\");\n"
"   Repl.start()\n"
"  }\n"
"  dunan dialen setRootDirectory_(dir)\n"
"}\n";

// Generated automatically from src/cli/*.msc. Do not edit.
static const char* resolverModuleSource =
"##package=resolver,cli\n"
"\n"
"kulu SiraSukuya {\n"
"  dialen SIMPLE { 1 }\n"
"  dialen ABSOLUTE { 2 }\n"
"  dialen RELATIVE { 3 }\n"
"\n"
"  dialen unixAbsolute(path) { path.beDamineNiin(\"/\") }\n"
"  dialen windowsAbsolute(path) {\n"
"    # TODO: is this not escaped properly by the stock Python code generator\n"
"    segin niin path.hakan >= 3 && path[1..2] == \":\\\\\"\n"
"  }\n"
"  dialen resolve(path) {\n"
"    nii (path.beDamineNiin(\".\")) segin niin SiraSukuya.RELATIVE\n"
"    nii (SiraSukuya.unixAbsolute(path)) segin niin SiraSukuya.ABSOLUTE\n"
"    nii (SiraSukuya.windowsAbsolute(path)) segin niin SiraSukuya.ABSOLUTE\n"
"\n"
"    segin niin SiraSukuya.SIMPLE\n"
"  }\n"
"}\n"
"\n"
"\n\n"
"##package=resolver,cli\n"
"kulu Sira {\n"
"  nin _path\n"
"  nin _sep\n"
"  dilan kura(path) {\n"
"    ale._path = path\n"
"    ale._sep = nii ale.appearsWindows()  \"\\\\\" note \"/\"\n"
"  }\n"
"  appearsWindows() {\n"
"    nii (ale._path.bAkono(\"\\\\\")) segin niin tien\n"
"    nii (ale._path.hakan>=2 && ale._path[1] == \":\") segin niin tien\n"
"  }\n"
"  sep { ale._sep || \"/\" }\n"
"  sebenma { ale._path }\n"
"  sanFe() { ale.kunBen(\"..\") } #up\n"
"  kunBen(path) { Sira.kura(ale._path + ale.sep + path).normalize }\n"
"  damineDo { #isRoot\n"
"    segin niin ale._path == \"/\"  ||\n"
"      ## C:\n"
"      (ale._path.hakan == 2 && ale._path[1] == \":\") ||\n"
"      ## F:\\\n"
"      (ale._path.hakan == 3 && ale._path[1..2] == \":\\\\\")\n"
"  }\n"
"  dirname {\n"
"    nii (ale._path==\"/\") segin niin ale\n"
"    nii (ale._path.beBanNiinAye(ale.sep)) segin niin Sira.kura(ale._path[0..-2])\n"
"    segin niin ale.sanFe()\n"
"  }\n"
"  dialen faraFara(path) {\n"
"    nin segments = []\n"
"    nin last = 0\n"
"    nin i = 0\n"
"    foo (i < path.hakan) {\n"
"      nin char = path[i]\n"
"      nii (char == \"/\" || char == \"\\\\\") {\n"
"        nii (last==i) {\n"
"          segments.aFaraAkan(\"\")\n"
"        } note {\n"
"          segments.aFaraAkan(path[last...i])\n"
"        }\n"
"        last = i + 1\n"
"      }\n"
"      i = i + 1\n"
"    }\n"
"    nii (last<path.hakan) {\n"
"      segments.aFaraAkan(path[last..-1])\n"
"    } note nii (last==i) {\n"
"      segments.aFaraAkan(\"\")\n"
"    }\n"
"    segin niin segments\n"
"  }\n"
"  normalize {\n"
"    ## nin paths = ale._path.split(ale.sep)\n"
"    nin paths = Sira.faraFara(ale._path)\n"
"    nin finalPaths = []\n"
"    nii (ale._path.beDamineNiin(\"/\")) finalPaths.aFaraAkan(\"/\")\n"
"    nii (paths[0]==\".\") finalPaths.aFaraAkan(\".\")\n"
"    seginka (paths kono path) {\n"
"      nin last = nii finalPaths.hakan > 0  finalPaths[-1] note gansan\n"
"      nii (path == \"..\") {\n"
"        nii (last == \"/\") ipan\n"
"\n"
"        nii (last == \".\")  {\n"
"          finalPaths[-1] = \"..\"\n"
"        } note nii (last == \"..\" || last == gansan) {\n"
"          finalPaths.aFaraAkan(\"$path\")\n"
"        } note {\n"
"          nii (finalPaths.hakan > 0) finalPaths.aBoOyorola(finalPaths.hakan - 1)\n"
"        }\n"
"      } note nii (path == \"\" || path == \".\") {\n"
"        ipan\n"
"      } note {\n"
"        finalPaths.aFaraAkan(path)\n"
"      }\n"
"    }\n"
"    nii (finalPaths.hakan>1 && finalPaths[0] == \"/\") finalPaths[0] = \"\"\n"
"    nin path = finalPaths.kunBen(ale.sep)\n"
"    nii (path == \"\") path = \".\"\n"
"    segin niin Sira.kura(path)\n"
"  }\n"
"}\n"
"\n\n"
"kulu Gninibaga {\n"
"  dialen nin __modules\n"
"  ## this is called at the end of this script when the CLI starts up\n"
"  ## and the Resolver VM is fired up\n"
"  dialen boot() {\n"
"    __modules = {}\n"
"  }\n"
"  dialen DEBUG { galon }\n"
"  dialen debug(s) {\n"
"    nii (ale.DEBUG) A.yira(s)\n"
"  }\n"
"  ## load a dynamic library\n"
"  dialen loadLibrary(name, file, root) {\n"
"    ale.debug(\"loadLibrary(`${name}`, `${file}`, `${root}`)\")\n"
"    nin libPath\n"
"    nin moduleDirectories = Gninibaga.findModulesDirectories(root)\n"
"    nii (moduleDirectories.laKalon) {\n"
"      Djuru.tike(\"dynamic libraries require a mosc_packages folder\")\n"
"    }\n"
"    seginka (moduleDirectories kono moduleDirectory) {\n"
"      ale.debug(\" - searching ${moduleDirectory}\")\n"
"      libPath = Sira.kura(moduleDirectory).kunBen(file).sebenma\n"
"      nii (Gafe.existsSync(libPath)) {\n"
"        ale.debug(\" - loading dynamic library `$file`\")\n"
"        Gafe.loadDynamicLibrary(name, libPath)\n"
"        segin\n"
"      }\n"
"    }\n"
"    Djuru.tike(\" # dynamic library `$name` - `$file` not found\")\n"
"  }\n"
"  dialen isLibrary(module) { module.bAkono(\":\") }\n"
"  ## Applies the CLI's import resolution policy. The rules are:\n"
"  ##\n"
"  ## * If [module] starts with \"./\" or \"../\", it is a relative import, relative\n"
"  ##   to [importer]. The resolved path is [name] concatenated onto the directory\n"
"  ##   containing [importer] and then normalized.\n"
"  ##\n"
"  ##   For example, importing \"./a/./b/../c\" from \"./d/e/f\" gives you \"./d/e/a/c\".\n"
"  dialen resolveModule(importer, module, rootDir) {\n"
"    ale.debug(\"resolveModule(`$importer`, `$module`, `$rootDir`)\")\n"
"    nii (ale.isLibrary(module)) {\n"
"      nin pieces = module.faraFara(\":\")\n"
"      module = pieces[1]\n"
"      nin libraryName = pieces[0]\n"
"      ## TODO: linux, windows, etc.\n"
"      nin platform = \"darwin\"\n"
"      nin ext = \"so\"\n"
"      nii(platform == \"darwin\") {\n"
"        ext = \"dylib\"\n"
"      }\n"
"      nin libraryFile = \"lib${pieces[0]}.$ext\"\n"
"      ale.loadLibrary(libraryName, libraryFile, rootDir)\n"
"      segin niin module\n"
"    }\n"
"    nii (SiraSukuya.resolve(module) == SiraSukuya.SIMPLE) segin niin module\n"
"\n"
"    ale.debug(\"dirname: ${Sira.kura(importer).dirname}\")\n"
"    nin path = Sira.kura(importer).dirname.kunBen(module)\n"
"    ale.debug(\"resolved: ${path.sebenma}\")\n"
"    segin niin path.sebenma\n"
"  }\n"
"\n"
"  ## walks the tree starting with current root and attemps to find\n"
"  ## `mosc_packages` which will be used to resolve modules in addition\n"
"  ## to built-in modules\n"
"  dialen findModulesDirectories(root) {\n"
"    ## switch to using absolute pathss\n"
"    root = Gafe.realPathSync(root)\n"
"    nii (__modules[root]) segin niin __modules[root]\n"
"    nin moduleCollections = []\n"
"\n"
"    nin path = Sira.kura(root + \"/\")\n"
"    foo(tien) {\n"
"      nin modules = path.kunBen(\"mosc_packages/\").sebenma\n"
"      ale.debug(\" ? checking for existance: $modules\")\n"
"      nii (Gafe.existsSync(modules)) {\n"
"        ale.debug(\"- found modules in $modules\")\n"
"        ## segin niin modules\n"
"        moduleCollections.aFaraAkan(modules)\n"
"      }\n"
"      nii (path.isRoot) atike\n"
"      path = path.sanFe()\n"
"    }\n"
"    __modules[root] = moduleCollections\n"
"    segin niin moduleCollections\n"
"  }\n"
"\n"
"  ## searches for a module inside `mosc_packages`\n"
"  ##\n"
"  ## If the module is a single bare name, treat it as a module with the same\n"
"  ## name inside the package. So \"foo\" means \"foo/foo\".\n"
"  ##\n"
"  ## returns the path to the .msc file that needs to be loaded\n"
"  dialen moduleGnini(root, module) {\n"
"    nin segment =nii (module.bAkono(\"/\")) {\n"
"      \"${module}.msc\"\n"
"    } note {\n"
"      \"${module}${module}.msc\"\n"
"    }\n"
"    nin moduleDirectory = Sira.kura(root).kunBen(segment).sebenma\n"
"    ale.debug(\"trying: ${moduleDirectory}\")\n"
"    nii (Gafe.existsSync(moduleDirectory)) {\n"
"      ale.debug(\"found module: ${moduleDirectory}\")\n"
"      segin niin moduleDirectory\n"
"    }\n"
"  }\n"
"\n"
"  ## Attempts to find the source for [module] relative to the current root\n"
"  ## directory.\n"
"  ##\n"
"  ## Returns the filename to load if found, or `:${module}` if not which\n"
"  ## is the pattern C uses to attempt a built-in module load, ie:\n"
"  ## returning `:os` will instruct C to use the internal `os` module.\n"
"  dialen loadModule(module, rootDir) {\n"
"    ale.debug(\"loadModule($module, $rootDir\")\n"
"    nin type = SiraSukuya.resolve(module)\n"
"    ale.debug(type)\n"
"    nii (type == SiraSukuya.ABSOLUTE || type == SiraSukuya.RELATIVE) {\n"
"      nin path = \"$module.msc\"\n"
"      segin niin path\n"
"    }\n"
"\n"
"    nin root = Gafe.realPathSync(rootDir)\n"
"    ale.debug(\"root: ${root}\")\n"
"    seginka (Gninibaga.findModulesDirectories(root) kono mosc_packages) {\n"
"      nin loc = ale.moduleGnini(mosc_packages, module)\n"
"      nii (loc != gansan) {\n"
"        ale.debug(\"found ${module} in ${mosc_packages}\")\n"
"        segin niin loc\n"
"      }\n"
"    }\n"
"    ale.debug(\"must be built-in? returning :$module\")\n"
"    ## must be built-in\n"
"    segin niin \":$module\"\n"
"  }\n"
"}\n"
"\n"
"kulu Gafe {\n"
"  dunan dialen loadDynamicLibrary(name, path)\n"
"  dunan dialen existsSync(s)\n"
"  dunan dialen realPathSync(s)\n"
"}\n"
"\n"
"Gninibaga.boot()\n";

// Generated automatically from src/cli/*.msc. Do not edit.
static const char* filenModuleSource =
"kabo \"io\" nani Npalan\n"
"kabo \"os\" nani Process\n"
"\n"
"kulu Color {\n"
"  dialen GREEN { \"\\u001b[32m\" }\n"
"  dialen RED { \"\\u001b[31m\" }\n"
"  dialen BOLD { \"\\u001b[1m\" }\n"
"  dialen RESET { \"\\u001b[0m\" }\n"
"}\n"
"\n"
"kulu DieGnogon {\n"
"  nin _name\n"
"  nin _version\n"
"  nin _source\n"
"  dilan kura(name, version, source) {\n"
"    ale._name = name\n"
"    ale._version = version\n"
"    ale._source = source\n"
"  }\n"
"  togo { ale._name }\n"
"  yelema { ale._version }\n"
"  source { ale._source }\n"
"  sebenma { \"DieGnogon(${ale._name} - ${ale._version}\" }\n"
"}\n"
"\n"
"kulu Runner {\n"
"  nin _jobs\n"
"  dilan kura() {\n"
"    ale._jobs = []\n"
"  }\n"
"  aFaraAkan(cmd, args) { ale.aFaraAkan(cmd,args,gansan) }\n"
"  aFaraAkan(cmd, args, path) {\n"
"    ale._jobs.aFaraAkan([cmd,args,path])\n"
"  }\n"
"  run(cmd, args) { ale.run(cmd,args,gansan) }\n"
"  run(cmd, args, cwd) {\n"
"    nin result\n"
"    A.yira(\" - [R] ${cmd} \" + args.join(\" \"))\n"
"    segin niin Process.exec(cmd, args, cwd)\n"
"  }\n"
"  go() {\n"
"    ale._jobs.kelenkelen { (job) =>\n"
"      nin r = ale.run(job[0], job[1], job[2])\n"
"      nii (r!=0) {\n"
"        Djuru.tike(\" - FAILED (got error code ${r})\")\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"nin ShowVersion = Tii.kura() {\n"
"  A.yira(\"filen v0.4.0 (embedded)\")\n"
"}\n"
"\n"
"kulu Filen {\n"
"  dilan kura() {}\n"
"  dieGnogonw { [] }\n"
"  togo { \"filen\" }\n"
"  list() {\n"
"    A.yira(\"${ale.togo} DieGnogonw:\")\n"
"    ale.dieGnogonw.kelenkelen { (dep) =>\n"
"      A.yira(\"- ${dep.togo} ${dep.yelema}\")\n"
"    }\n"
"  }\n"
"  default() {\n"
"    nii ([\"[-v]\",\"[--version]\"].bAkono(Process.arguments.sebenma)) {\n"
"      ShowVersion.call()\n"
"    } note nii (Process.arguments.sebenma == \"[install]\") {\n"
"      ale.install()\n"
"    } note {\n"
"      A.yira(\"Usage:\\n./filen.msc install\\n\")\n"
"      ale.list()\n"
"    }\n"
"  }\n"
"  install() {\n"
"    nii (!Npalan.exists(\"mosc_packages\")) Npalan.create(\"mosc_packages\")\n"
"    ale.dieGnogonw.each { (dep) =>\n"
"        A.yira(\" - installing ${dep.togo} ${dep.yelema}\")\n"
"      nii (Npalan.exists(\"mosc_packages/${dep.togo}\")) {\n"
"        A.yira(\" - ${dep.togo} already installed. To reinstall, remove first.\")\n"
"        ## Process.exec(\"git\", [\"fetch\",\"--all\"], \"mosc_packages/${dep.togo}\")\n"
"        ## Process.exec(\"git\", [\"checkout\", dep.yelema], \"mosc_packages/${dep.togo}\")\n"
"      } note {\n"
"        ## nin args = [\"clone\",\"-q\",\"-b\", dep.yelema,dep.source, \"mosc_packages/${dep.togo}\"]\n"
"        nin run=Runner.kura()\n"
"        run.aFaraAkan(\"git\", [\"clone\",\"-q\",dep.source,\"mosc_packages/${dep.togo}\"])\n"
"        run.aFaraAkan(\"git\",[\"checkout\", \"--detach\", dep.yelema], \"mosc_packages/${dep.togo}\")\n"
"        nin f = Djuru.kura { run.go() }\n"
"        f.aladje()\n"
"        nii (f.fili != gansan) {\n"
"          A.yira(\" - Could not install dependency ${dep.togo} ${dep.yelema}\")\n"
"          A.yira(\" * ${ale.dieGnogonw.hakan} dependency(s). ${Color.RED}Failed to install.${Color.RESET}\")\n"
"          Process.exit(1)\n"
"        }\n"
"      }\n"
"    }\n"
"    A.yira(\" * ${ale.dependencies.hakan} dependency(s). ${Color.GREEN}All good.${Color.RESET}\")\n"
"  }\n"
"}\n";

